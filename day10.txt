**final
1.final 변수
=>변수 앞에 final을 붙여서 변수의 값을 변경하지 못하도록 하는 것
=>명확한 의미를 전달해야 하거나(의미 전달, 옵션) 읽기 전용을 만드는 것입니다.
=>이 변수를 만들 때는 이름을 모두 대문자로 만드는 것이 관례

2.final 메소드
=>오버라이딩을 할 수 없는 메소드: 시스템과 관련된 메소드라서 수정해서 사용하지 않도록 한 것입니다.

3.final 클래스
=>상속을 할 수 없는 클래스

**inner class
=>클래스 안에 만든 클래스
=>자바는 클래스 안에 클래스를 생성하는 것이 가능
1.inner class
=>class 안에 만든 클래스
=>별도의 클래스로 만들기에는 외부에서 거의 사용이 안될 것 같은 경우 자신이 사용되는 클래스 안에 만들어서 사용

2. static inner class
=>inner class 안에 static 멤버가 있으면 일반 클래스로 만들면 에러
class 라는 예약어 앞에 static 을 붙여서 생성

3.local inner class
=>메소드 안에 만든 클래스
=>이 클래스는 메소드 안에서만 사용할 수 있습니다.

4.anonymous class
=>클래스를 상속받거나 인터페이스를 구현해야 하는 경우 별도의 클래스를 만들지 않고 바로 인스턴스를 만들어서 사용하는 문법
=>GUI(Windows Programming), Android, Big Data 처리 분야에 많이 사용합니다.

new 상위클래스이름 이나 인터페이스이름(){
	필요한 내용 정의
};

**Java API
1.API(Application Programming Interface)
=>응용 프로그램을 만들 수 있는 제공해주는 것
=>SDK(Software Development Kit)
=>JDK - Java Development Kit : Java에서 응용 프로그램을 만들 수 있도록 제공해주는 것
=>여기서 제공해주는 것들은 우리가 만든 것이 아니므로 도큐먼트를 보면서 사용을 해야 합니다.

2.Class & Interface
=>Abstract Class 와 Interface는 new를 못하기 때문에 상속을 통해서만 사용 가능합니다.
=>final Class 는 상속을 못합니다.
//상속계층
java.lang.Object
java.lang.String

//구현 된 인터페이스
All Implemented Interfaces:
Serializable, CharSequence, Comparable<String>

//하위 클래스가 보이기도 합니다.

3.Field Summary
=>클래스의 static 상수
=>클래스이름.이름 으로 사용합니다.
=>이름이 대문자로 되어 있으면 클래스 내부에있는 메소드에서 사용할 옵션입니다.

4.Constructor(생성자) - 인스턴스를 만들 때 호출하는 메소드
=>생성자의 개수만큼 인스턴스를 만들 수 있는 방법이 제공됩니다.
=>생성자가 없는 경우
abstract class 나 interface 인지 확인 - 인스턴스를 만들 수 없기 때문에 제공 안함
하단의 모든 메소드가 static 인지 확인 - 모든 멤버가 static 이면 인스턴스를 필요가 없기 때문
위 2가지 경우가 아닌 경우 - 자신의 클래스 이름 뒤에 Builder 나 Factory 가 붙는 클래스가 있는지 또는 자신의 메소드 중에서 static 메소드 중에 자신을 리턴하는 메소드가 있는지 확인

5.Method
=>static 이 있는지 없는지 확인
static 이 있으면 클래스로 호출하고 없으면 인스턴스로 호출

=>매개변수 확인
어떤 종류의 데이터를 몇 개 어떤 순서로 대입해서 호출해야 하는지 확인

=>return type 확인
메소드 호출 결과가 어떻게 되는지 확인

**Exception Handling
1.프로그램 상에서 발생하는 문제
1)물리적 오류: 문법에 맞지 않아서 발생하는 에러
=>오류가 발생하면 실행이 안됨
=>IDE에서는 왼쪽에 빨간색으로 표시

2)논리적 오류: 문법에는 맞는데 알고리즘의 오류로 인해서 잘못된 결과가 나오는 경우
=>디버깅을 통해서 해결

3)예외(exception): 문법에는 맞아서 실행이 되는데 특수한 상황이 발생하면 프로그램이 중단되는 현상
=>개발자의 잘못인 경우는 디버깅을 통해서 해결
=>해결할 수 없는 문제라면 예외처리를 해주어야 합니다.

4)단언(assertion): 문법에 이상도 없고 예외도 없지만 개발자가 고의적으로 프로그램을 중단시키는 것
=>특정 조건에 맞지 않으면 프로그램을 중단하기 위해서 작성

2.debugging
=>프로그램을 부분적으로 실행시키면서 메모리의 값을 확인하는 작업
=>이클립스에서는 코드의 왼쪽 부분에서 마우스 오른쪽을 눌러서 중단점(break point)을 설정하고 [Run] - [Debug] 메뉴를 누르면 수행됩니다.
디버그 모드로 변경할 지 묻는 창이 나옵니다.
=>디버그 모드에서 원래 모드로 돌아올 때는 오른쪽 상단의 perspective 에서 java 로 변경해주면 됩니다.

3.Exception Handling(예외 처리)
1)Exception(예외)
=>문법에는 문제가 없어서 실행은 되지만 중간에 프로그램이 중단되는 현상

2)예외 처리
=>예외가 발생했을 때 수행할 내용을 작성하는 것

3)예외 처리 목적
=>예외가 발생하면 그 내용을 기록하는 것
=>예외가 발생하더라도 프로그램을 계속 수행하시키기 위해서

















